//
// Created by Иван on 10/21/2024.
//


#include "NetGeometry.h"

Node::Node(int index, double xCoord, double yCoord, double zCoord)
        : ind(index), x(xCoord), y(yCoord), z(zCoord) {}

Element::Element(const int index, const std::vector<int> &nIndexes, int size)
        : ind(index), nodeIndexes(nIndexes), dim(size), edgeIndexes() {
}

Edge::Edge(int index, int node1, int node2, int neighbor1, int neighbor2, int orient, double len, const std::vector<double>& normalVec)
        : ind(index), nodeInd1(node1), nodeInd2(node2),
          neighbourInd1(neighbor1), neighbourInd2(neighbor2),
          orientation(orient), length(len), normalVector(normalVec) {}


double areaCalc(const Element& poly, const NodePool& nPool) {
    int dim = poly.dim;
    std::vector<Node> polyNodes;
    for(int i = 0; i < dim; ++i){
        polyNodes.push_back(nPool.nodes[poly.nodeIndexes[i]]);
    }
    double res = 0.0;
    double iSum = 0.0;
    double jSum = 0.0;
    double kSum = 0.0;
    for(int k = 1; k < dim-1; ++k){
        double yk_y1 = polyNodes[k].y - polyNodes[0].y;  //y_k - y_1
        double zk1_z1 = polyNodes[k+1].z - polyNodes[0].z; // z_{k+1} - z_1
        double zk_z1 = polyNodes[k].z - polyNodes[0].z;
        double yk1_y1 = polyNodes[k+1].y - polyNodes[0].y;
        double xk1_x1 = polyNodes[k+1].x - polyNodes[0].x;
        double xk_x1 = polyNodes[k].x - polyNodes[0].x;
        iSum += (yk_y1 * zk1_z1 - zk_z1 * yk1_y1);
        jSum += (zk_z1 * xk1_x1 - xk_x1 * zk1_z1);
        kSum += (xk_x1 * yk1_y1 - yk_y1 * xk1_x1);
    }
    res = 0.5 * std::sqrt(iSum*iSum + jSum*jSum + kSum*kSum);
    return res;
}

std::vector<double> getElementCentroid2D(const Element &poly, const NodePool &nPool) {
    int dim = poly.dim;
    std::vector<double> centroid(2, 0.0);
    for(int i = 0; i < dim; ++i){
        Node node = nPool.getNode(poly.nodeIndexes[i]);
        centroid[0] += node.x;
        centroid[1] += node.y;
    }
    centroid[0] /= dim;
    centroid[1] /= dim;
    return centroid;
}

std::vector<double> getMidPoint2D(const int nodeInd1, const int nodeInd2, const NodePool &nPool) {
    Node node1 = nPool.getNode(nodeInd1);
    Node node2 = nPool.getNode(nodeInd2);
    std::vector<double> mid{(node1.x + node2.x)/2.0, (node1.y + node2.y)/2.0};
    return mid;
}

double getDistance(const int nodeInd1, const int nodeInd2, const NodePool& nPool){
    Node node1 = nPool.getNode(nodeInd1);
    Node node2 = nPool.getNode(nodeInd2);
    return std::sqrt( (node1.x - node2.x)*(node1.x - node2.x) + (node1.y - node2.y)*(node1.y - node2.y) + (node1.z - node2.z)*(node1.z - node2.z) );
}


NodePool::NodePool(int size, const std::vector<Node>& nodeVec)
        : nodeCount(size), nodes(nodeVec) {}

Node NodePool::getNode(int ind) const{
    return nodes[ind];
}

EdgePool::EdgePool(int size, const std::vector<Edge>& edgeVec)
        : edgeCount(size), edges(edgeVec) {}


// Function to calculate the 2D normal vector between two nodes
std::vector<double> calculateNormalVector2D(const Node& node1, const Node& node2) {
    // Calculate the direction vector from node1 to node2
    double dx = node2.x - node1.x;
    double dy = node2.y - node1.y;

    // Calculate the normal vector (perpendicular to the direction vector)
    // Counterclockwise 90-degree rotation
    std::vector<double> normal = {-dy, dx};

    // Optionally, normalize the normal vector
    double length = std::sqrt(normal[0] * normal[0] + normal[1] * normal[1]);
    if (length > 0) {
        normal[0] /= length;
        normal[1] /= length;
    }
    return normal;
}

////ЖЁТСКИЙ КОСТЫЛЬ, УБЕРУ ПОТОМ , КОГДА БУДЕТ МЕСТО НА BOOST
    namespace std {
    template <typename T1, typename T2>
    struct hash<std::pair<T1, T2>> {
        size_t operator()(const std::pair<T1, T2>& p) const {
            auto h1 = std::hash<T1>{}(p.first);
            auto h2 = std::hash<T2>{}(p.second);
            return h1 ^ (h2 << 1); // Combine the two hash values
        }
    };
}
EdgePool::EdgePool(const NodePool& np, ElementPool& ep) {
    //<key type, calue type, hash function>
    // is a hash function specifically designed for hashing std::pair<int, int> objects. The hash value generated by this function is used to distribute the pairs across the hash table.
    //!!!!!!!!!TODO:убрать бред с кастомом и добавить boost:hash
    std::unordered_map<std::pair<int, int>, std::unordered_set<int>, std::hash<std::pair<int, int>>> edgeMap;
    int edgeIndex = 0;

    // Loop through each element to create edges
    for (const auto& element : ep.elements) {
        int dim = element.dim;
        for (int i = 0; i < dim; ++i) {
            int node1 = element.nodeIndexes[i];
            int node2 = element.nodeIndexes[(i + 1) % dim]; // Ensure cyclical connectivity
            if (node1 > node2) std::swap(node1, node2); // Ensure consistent ordering
            auto edgeKey = std::make_pair(node1, node2);
            edgeMap[edgeKey].insert(element.ind); // Insert element index into the unordered_set for this edge
        }
    }

    // Now iterate through the edgeMap to create edges
    for (const auto& edgeEntry : edgeMap) {
        int node1 = edgeEntry.first.first;
        int node2 = edgeEntry.first.second;
        const auto& neighbors = edgeEntry.second; // Get the set of neighboring elements
        int neighbor1 = -1, neighbor2 = -1;
        auto it = neighbors.begin();
        if (it != neighbors.end()) {
            neighbor1 = *it;
            ++it;
            if (it != neighbors.end()) {
                neighbor2 = *it;
            }
        }
        int orientation = 1;
        std::vector<double> normalVector = calculateNormalVector2D(np.getNode(node1), np.getNode(node2));  // You can compute the normal vector if needed
        if(neighbor1 == -1){
            std::swap(neighbor1,neighbor2);
        }
        std::vector<double> edgeMid = getMidPoint2D(node1, node2, np);
        std::vector<double> neighbour1ToEdgeMidVector =
                    edgeMid - getElementCentroid2D(ep.elements[neighbor1], np);
        orientation = normalVector * neighbour1ToEdgeMidVector > 0 ? 1 : -1;
        double len = getDistance(node1, node2, np);
        // Create the edge and add it to the list
        edges.emplace_back(edgeIndex, node1, node2, neighbor1, neighbor2, orientation, len, normalVector);

        // Update edge indexes for the neighbors
        if (neighbor1 != -1) {
            ep.elements[neighbor1].edgeIndexes.push_back(edgeIndex);
        }
        if (neighbor2 != -1) {
            ep.elements[neighbor2].edgeIndexes.push_back(edgeIndex);
        }

        ++edgeIndex;
    }

    edgeCount = edges.size();  // Set the total number of edges
}

ElementPool::ElementPool(int nodesPerElement, int elCnt, const std::vector<Element>& elems)
        : elCount(elCnt), isSquare(nodesPerElement == SQUARE_ELEMENT_NODE_COUNT),
          isTriangular(nodesPerElement == TRIANGULAR_ELEMENT_NODE_COUNT), elements(elems) {}

void World::setNodePool(const NodePool& np) {
    this->np = np;
}

NodePool World::getNodePool() const {
    return np;
}

void World::setElementPool(const ElementPool& ep) {
    this->ep = ep;
}

ElementPool World::getElementPool() const {
    return ep;
}

/*NEIGHBOUR SERVICE*/
NeighbourService::NeighbourService(const NodePool& np, const ElementPool& ep, const EdgePool& edgePool) {
    // Populate nodeToElements and elementToElements
    for (const auto& element : ep.elements) {
        for (int nodeIndex : element.nodeIndexes) {
            nodeToElements[nodeIndex].insert(element.ind);
        }
        for (int edgeIndex : element.edgeIndexes) {
            edgeToElements[edgeIndex].insert(element.ind);
        }
    }

    // Populate elementToElements using shared nodes
    for (const auto& element : ep.elements) {
        std::unordered_set<int> connectedElements;
        for (int nodeIndex : element.nodeIndexes) {
            for (int neighbourIndex : nodeToElements[nodeIndex]) {
                if (neighbourIndex != element.ind) {
                    connectedElements.insert(neighbourIndex);
                }
            }
        }
        elementToElements[element.ind] = connectedElements;
    }

    for (int edgeIndex = 0; edgeIndex < edgePool.edges.size(); ++edgeIndex) {
        const auto& edge = edgePool.edges[edgeIndex];
        nodeToEdgesMap[edge.nodeInd1].push_back(edgeIndex);
        nodeToEdgesMap[edge.nodeInd2].push_back(edgeIndex);
    }
}

std::vector<int> NeighbourService::getEdgeNeighborsOfNode(int nodeIndex) const {
    auto it = nodeToEdgesMap.find(nodeIndex);
    if (it != nodeToEdgesMap.end()) {
        return it->second; // Return the list of edge indexes
    }
    return {}; // Return an empty vector if the node is not found
}

std::unordered_set<int> NeighbourService::getNodeNeighbours(int nodeIndex) const {
    return nodeToElements.at(nodeIndex);
}

std::unordered_set<int> NeighbourService::getEdgeNeighbours(int edgeIndex) const {
    return edgeToElements.at(edgeIndex);
}

std::unordered_set<int> NeighbourService::getElementNeighbours(int elementIndex) const {
    return elementToElements.at(elementIndex);
}

// Method to get edges of an element
std::unordered_set<int> NeighbourService::getEdgesOfElement(int elementIndex) const {
    return elementToEdges.at(elementIndex);
}

// Method to get elements of an edge
std::unordered_set<int> NeighbourService::getElementsOfEdge(int edgeIndex) const {
    return edgeToElementsMap.at(edgeIndex);
}


// Displaying neighbors and the relationships between nodes, elements, and edges
void NeighbourService::displayNeighbours() const {
    std::cout << "\n--- Neighbours ---" << std::endl;

    // Node to Element Neighbours
    std::cout << "\nNode to Element Neighbours:" << std::endl;
    for (const auto& [node, elements] : nodeToElements) {
        std::cout << "Node " << node << ": ";
        for (int elem : elements) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    // Element to Element Neighbours
    std::cout << "\nElement to Element Neighbours:" << std::endl;
    for (const auto& [element, neighbours] : elementToElements) {
        std::cout << "Element " << element << ": ";
        for (int neigh : neighbours) {
            std::cout << neigh << " ";
        }
        std::cout << std::endl;
    }

    // Edge to Element Neighbours
    std::cout << "\nEdge to Element Neighbours:" << std::endl;
    for (const auto& [edge, elements] : edgeToElements) {
        std::cout << "Edge " << edge << ": ";
        for (int elem : elements) {
            std::cout << elem << " ";
        }
        std::cout << std::endl;
    }

    // Node to Edges
    for(const auto& [node, edges]: nodeToEdgesMap) {
        std::cout << "Node " << node << " is connected to edges: ";
        for(const auto& edge: edges) {
            std::cout << edge << " ";
        }
        std::cout << std::endl;
    }
}


/*WORLD*/
NeighbourService& World::getNeighbourService() {
    return ns;
}

World::World(const std::string& fileName) : np(), ep(), edgp(), ns(np, ep, edgp) {
    std::ifstream file(fileName);
    assert(file.is_open());

    std::vector<Node> nodes;
    std::vector<Element> elements;
    std::string tmp_line;

    while (std::getline(file, tmp_line)) {
        if (tmp_line == "$Nodes") {
            std::getline(file, tmp_line);  // Size
            std::getline(file, tmp_line);  // First enter
            while (tmp_line != "$EndNodes") {
                int ind;
                double x, y, z;
                std::istringstream ss(tmp_line);
                ss >> ind >> x >> y >> z;  // Read all values in one go
                nodes.emplace_back(ind-1, x, y, z);
                std::getline(file, tmp_line);
            }
        } else if (tmp_line == "$Elements") {
            std::getline(file, tmp_line); // Size
            std::getline(file, tmp_line); // First enter
            while (tmp_line != "$EndElements") {
                int ind, count;
                std::istringstream ss(tmp_line);
                ss >> ind >> count; // Read index and count

                std::vector<int> indexes(count);
                for (int i = 0; i < count; ++i) {
                    ss >> indexes[i]; // Directly read into vector
                    indexes[i]-=1;
                }
                elements.emplace_back(ind, indexes, count);
                std::getline(file, tmp_line);
            }
        }
    }

    np = NodePool(nodes.size(), nodes);
    ep = ElementPool(nodes[0].ind, elements.size(), elements); // Assuming nodes[0].ind is the nodesPerElement
    edgp = EdgePool(np, ep);  // Construct edges based on NodePool and ElementPool
    ns = NeighbourService(np, ep, edgp);

    for(int i = 0; i < ep.elCount; ++i){
        ep.elements[i].area = areaCalc(ep.elements[i], np);
    }

}

void World::display() const {
    // Display Node Pool
    std::cout << "Node Pool:" << std::endl;
    std::cout << "Total Nodes: " << np.nodeCount << std::endl;
    for (const auto& node : np.nodes) {
        std::cout << "Node Index: " << node.ind << ", Coordinates: ("
                  << node.x << ", " << node.y << ", " << node.z << ")" << std::endl;
    }

    // Display Element Pool
    std::cout << "\nElement Pool:" << std::endl;
    std::cout << "Total Elements: " << ep.elCount << std::endl;
    for (const auto& element : ep.elements) {
        std::cout << "Element Index: " << element.ind << ", Node Count: " << element.dim
                  << ", Node Indices: ";
        for (const auto& index : element.nodeIndexes) {
            std::cout << index << " ";
        }
        std::cout << ", Area: " << element.area << ", Edges: (";
        for(const auto& index: element.edgeIndexes){
            std::cout << index << " ";
        }
        std::cout << ")"<<std::endl;
    }

    // Display Edge Pool and Edge Neighbors
    std::cout << "\nEdge Pool:" << std::endl;
    std::cout << "Total Edges: " << edgp.edgeCount << std::endl;
    for (const auto& edge : edgp.edges) {
        std::cout << "Edge Index: " << edge.ind << ", Nodes: ("
                  << edge.nodeInd1 << ", " << edge.nodeInd2 << "), "
                  << "Neighbors: (" << edge.neighbourInd1 << ", " << edge.neighbourInd2 << ")"
                  << ", Orientation: " << edge.orientation << ", Normal: ("
                  << edge.normalVector[0] << ", " << edge.normalVector[1] << "), len = "
                  << edge.length << std::endl;
    }

    // Display Neighbor Information for Nodes, Edges, and Elements
    ns.displayNeighbours();
}

EdgePool World::getEdgePool() const {
    return edgp;
}

void World::setEdgePool(const EdgePool &edgp) {
    this->edgp = edgp;
}

void setNeighbourEdge(Element& el, const int edgeInd){
    el.nodeIndexes.push_back(edgeInd);
}
